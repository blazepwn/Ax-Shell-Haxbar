import os
import re
import subprocess

from fabric.widgets.box import Box
from fabric.widgets.button import Button
from fabric.widgets.label import Label
from gi.repository import GLib

import modules.icons as icons
from modules.buttons import add_hover_cursor
from utils.async_subprocess import run_command_with_output_async


def _first_ipv4(text: str) -> str | None:
    """Return the first IPv4 address found in text."""
    match = re.search(r"\b(\d{1,3}(?:\.\d{1,3}){3})\b", text)
    return match.group(1) if match else None


def copy_to_clipboard_async(text: str) -> None:
    """Copy text to clipboard without blocking the UI."""

    def worker(user_data):
        try:
            subprocess.run(["wl-copy"], input=user_data.encode("utf-8"), check=True)
        except Exception:
            pass
        return None

    GLib.Thread.new("copy-clipboard", worker, text)


class LocalIPWidget(Button):
    """Shows the current local IP without blocking the UI."""

    def __init__(self, **kwargs):
        self.icon = Label(markup=icons.wifi_3)
        self.text = Label(name="local-ip-label", label="No IP")
        self.current_ip: str | None = None

        super().__init__(
            name="local-ip",
            tooltip_text="Local IP",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
            on_clicked=self.on_click,
        )
        add_hover_cursor(self)

        self.notch = kwargs.get("notch")
        self.selected_interface = None

        self.update_ip()
        GLib.timeout_add_seconds(2, self.update_ip)

    def update_ip(self):
        if self.selected_interface:
            self._check_interface(self.selected_interface)
            return True

        def on_route(output: bytes):
            ip = self._parse_route_output(output.decode("utf-8", errors="ignore"))
            if ip:
                self._set_ip(ip)
            else:
                self._fallback_hostname()

        def on_route_error(_error: Exception):
            self._fallback_hostname()

        run_command_with_output_async(
            ["ip", "-4", "route", "get", "1.1.1.1"],
            on_success=on_route,
            on_error=on_route_error,
        )
        return True

    def _fallback_hostname(self):
        def on_hostname(output: bytes):
            ip = _first_ipv4(output.decode("utf-8", errors="ignore"))
            self._set_ip(ip)

        def on_hostname_error(_error: Exception):
            self._set_ip(None)

        run_command_with_output_async(
            ["hostname", "-I"], on_success=on_hostname, on_error=on_hostname_error
        )

    def _set_ip(self, ip: str | None):
        self.current_ip = ip
        self.text.set_label(ip if ip else "No IP")

    @staticmethod
    def _parse_route_output(output: str) -> str | None:
        match = re.search(r"\bsrc\s+(\d{1,3}(?:\.\d{1,3}){3})", output)
        return match.group(1) if match else None

    def copy_ip(self, *_):
        if not self.current_ip:
            return
        copy_to_clipboard_async(self.current_ip)

    def on_click(self, *_):
        if self.notch:
            self.notch.open_notch("network")
        else:
            self.copy_ip()

    def set_interface(self, iface_name):
        self.selected_interface = iface_name
        self.update_ip()

    def _check_interface(self, iface: str, fallback=None):
        def on_success(output: bytes):
            ip = self._parse_interface_output(output.decode("utf-8", errors="ignore"))
            if ip:
                self._set_ip(ip)
            elif fallback:
                fallback()
            else:
                self._set_ip(None)

        def on_error(_error: Exception):
            if fallback:
                fallback()
            else:
                self._set_ip(None)

        run_command_with_output_async(
            ["ip", "-4", "-o", "addr", "show", "dev", iface],
            on_success=on_success,
            on_error=on_error,
        )

    def _parse_interface_output(self, output: str) -> str | None:
        match = re.search(r"\binet\s+(\d{1,3}(?:\.\d{1,3}){3})/", output)
        return match.group(1) if match else None


class HtbIPWidget(Button):
    """Displays Hack The Box VPN IP if connected."""

    def __init__(self, **kwargs):
        self.icon = Label(markup=icons.world_off)
        self.text = Label(name="htb-ip-label", label="Disconnected")
        self.current_ip: str | None = None

        super().__init__(
            name="htb-ip",
            tooltip_text="HTB VPN",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
            on_clicked=self.on_click,
        )
        add_hover_cursor(self)

        self.notch = kwargs.get("notch")
        self.update_ip()
        GLib.timeout_add_seconds(2, self.update_ip)

    def on_click(self, *_):
        if self.notch:
            self.notch.open_notch("vpn")
        else:
            self.copy_ip()

    def update_ip(self):
        self._check_interface("tun0", fallback=lambda: self._check_interface("tun1"))
        return True

    def _check_interface(self, iface: str, fallback=None):
        def on_success(output: bytes):
            ip = self._parse_interface_output(output.decode("utf-8", errors="ignore"))
            if ip:
                self._set_connected(ip)
            elif fallback:
                fallback()
            else:
                self._set_disconnected()

        def on_error(_error: Exception):
            if fallback:
                fallback()
            else:
                self._set_disconnected()

        run_command_with_output_async(
            ["ip", "-4", "-o", "addr", "show", "dev", iface],
            on_success=on_success,
            on_error=on_error,
        )

    def _set_connected(self, ip: str):
        self.current_ip = ip
        self.text.set_label(ip)
        self.icon.set_markup(icons.world)
        self.remove_style_class("disconnected")

    def _set_disconnected(self):
        self.current_ip = None
        self.text.set_label("Disconnected")
        self.icon.set_markup(icons.world_off)
        self.add_style_class("disconnected")

    def _parse_interface_output(self, output: str) -> str | None:
        match = re.search(r"\binet\s+(\d{1,3}(?:\.\d{1,3}){3})/", output)
        return match.group(1) if match else None

    def copy_ip(self, *_):
        if not self.current_ip:
            return
        copy_to_clipboard_async(self.current_ip)


class TargetWidget(Button):
    """Displays the current target from scripts/target."""

    def __init__(self, **kwargs):
        self.icon = Label(markup=icons.radar)
        self.text = Label(name="target-label", label="No target")
        self.target_file = os.path.expanduser("~/.config/Ax-Shell/scripts/target")
        self.notch = kwargs.get("notch")

        super().__init__(
            name="target",
            tooltip_text="Target",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
            on_clicked=self.on_click,
        )
        add_hover_cursor(self)

        self.current_ip: str | None = None

        self.update_target()
        GLib.timeout_add_seconds(1, self.update_target)

    def on_click(self, *_):
        if self.notch:
            self.notch.open_notch("target")
        else:
            self.copy_target()

    def update_target(self):
        try:
            with open(self.target_file, "r") as f:
                content = f.read().strip()
        except FileNotFoundError:
            self._set_target(None, "No target")
            return True
        except Exception:
            self._set_target(None, "No target")
            return True

        if not content:
            self._set_target(None, "No target")
            return True

        parts = content.split(maxsplit=1)
        if len(parts) == 1:
            ip = parts[0]
            display = ip
        else:
            ip, name = parts[0], parts[1]
            display = f"{name} - {ip}"

        self._set_target(ip, display)
        return True

    def _set_target(self, ip: str | None, display: str):
        self.current_ip = ip
        self.text.set_label(display)

    def copy_target(self, *_):
        if not self.current_ip:
            return
        copy_to_clipboard_async(self.current_ip)
