import os
import re
import subprocess

from fabric.utils.helpers import exec_shell_command_async
from fabric.widgets.box import Box
from fabric.widgets.button import Button
from fabric.widgets.label import Label
from gi.repository import GLib

import modules.icons as icons
from utils.async_subprocess import run_command_with_output_async


def _first_ipv4(text: str) -> str | None:
    """Return the first IPv4 address found in text."""
    match = re.search(r"\b(\d{1,3}(?:\.\d{1,3}){3})\b", text)
    return match.group(1) if match else None


class LocalIPWidget(Button):
    """Shows the current local IP without blocking the UI."""

    def __init__(self):
        self.icon = Label(markup=icons.wifi_3)
        self.text = Label(name="local-ip-label", label="No IP")

        super().__init__(
            name="local-ip",
            tooltip_text="Local IP",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
        )

        self.update_ip()
        GLib.timeout_add_seconds(2, self.update_ip)

    def update_ip(self):
        def on_route(output: bytes):
            ip = self._parse_route_output(output.decode("utf-8", errors="ignore"))
            if ip:
                self.text.set_label(ip)
            else:
                self._fallback_hostname()

        def on_route_error(_error: Exception):
            self._fallback_hostname()

        run_command_with_output_async(
            ["ip", "-4", "route", "get", "1.1.1.1"],
            on_success=on_route,
            on_error=on_route_error,
        )
        return True

    def _fallback_hostname(self):
        def on_hostname(output: bytes):
            ip = _first_ipv4(output.decode("utf-8", errors="ignore"))
            self.text.set_label(ip if ip else "No IP")

        def on_hostname_error(_error: Exception):
            self.text.set_label("No IP")

        run_command_with_output_async(
            ["hostname", "-I"], on_success=on_hostname, on_error=on_hostname_error
        )

    @staticmethod
    def _parse_route_output(output: str) -> str | None:
        match = re.search(r"\bsrc\s+(\d{1,3}(?:\.\d{1,3}){3})", output)
        return match.group(1) if match else None


class HtbIPWidget(Button):
    """Displays Hack The Box VPN IP if connected."""

    def __init__(self):
        self.icon = Label(markup=icons.world_off)
        self.text = Label(name="htb-ip-label", label="Disconnected")
        self.current_ip: str | None = None

        super().__init__(
            name="htb-ip",
            tooltip_text="HTB VPN",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
            on_clicked=self.copy_ip,
        )

        self.update_ip()
        GLib.timeout_add_seconds(2, self.update_ip)

    def update_ip(self):
        self._check_interface("tun0", fallback=lambda: self._check_interface("tun1"))
        return True

    def _check_interface(self, iface: str, fallback=None):
        def on_success(output: bytes):
            ip = self._parse_interface_output(output.decode("utf-8", errors="ignore"))
            if ip:
                self._set_connected(ip)
            elif fallback:
                fallback()
            else:
                self._set_disconnected()

        def on_error(_error: Exception):
            if fallback:
                fallback()
            else:
                self._set_disconnected()

        run_command_with_output_async(
            ["ip", "-4", "-o", "addr", "show", "dev", iface],
            on_success=on_success,
            on_error=on_error,
        )

    def _set_connected(self, ip: str):
        self.current_ip = ip
        self.text.set_label(ip)
        self.icon.set_markup(icons.world)
        self.remove_style_class("disconnected")

    def _set_disconnected(self):
        self.current_ip = None
        self.text.set_label("Disconnected")
        self.icon.set_markup(icons.world_off)
        self.add_style_class("disconnected")

    def _parse_interface_output(self, output: str) -> str | None:
        match = re.search(r"\binet\s+(\d{1,3}(?:\.\d{1,3}){3})/", output)
        return match.group(1) if match else None

    def copy_ip(self, *_):
        if not self.current_ip:
            return
        try:
            subprocess.run(
                ["wl-copy"], input=self.current_ip.encode("utf-8"), check=True
            )
        except Exception:
            # Fallback to async shell if direct call fails
            exec_shell_command_async(f'printf "%s" "{self.current_ip}" | wl-copy')


class TargetWidget(Button):
    """Displays the current target from scripts/target."""

    def __init__(self):
        self.icon = Label(markup=icons.radar)
        self.text = Label(name="target-label", label="No target")
        self.target_file = os.path.expanduser("~/.config/Ax-Shell/scripts/target")

        super().__init__(
            name="target",
            tooltip_text="Target",
            child=Box(orientation="h", spacing=6, children=[self.icon, self.text]),
            on_clicked=self.copy_target,
        )

        self.current_display: str | None = None

        self.update_target()
        GLib.timeout_add_seconds(1, self.update_target)

    def update_target(self):
        try:
            with open(self.target_file, "r") as f:
                content = f.read().strip()
        except FileNotFoundError:
            self._set_display("No target")
            return True
        except Exception:
            self._set_display("No target")
            return True

        if not content:
            self._set_display("No target")
            return True

        parts = content.split(maxsplit=1)
        if len(parts) == 1:
            display = parts[0]
        else:
            ip, name = parts[0], parts[1]
            display = f"{name} - {ip}"

        self._set_display(display)
        return True

    def _set_display(self, text: str):
        self.current_display = text
        self.text.set_label(text)

    def copy_target(self, *_):
        if not self.current_display or self.current_display == "No target":
            return
        try:
            subprocess.run(
                ["wl-copy"], input=self.current_display.encode("utf-8"), check=True
            )
        except Exception:
            exec_shell_command_async(f'printf "%s" "{self.current_display}" | wl-copy')
